import ares
import sys,os
import freephil as phil
import ares.import_file

__all__ = []
__version__ = ares.__version__
prog_short_description = 'Integrates series of frames from SEC-SAXS'

phil_sec_str =  '''
sec {
    sort = True
    .help = Sort the input files by header time. If False, the order as in input list used.
    .type = bool
    
    output {
        prefix = frame
        .help = Prefix of output files
        .type = str
        directory = sec_by_frame
        .help = output directory
        .type = path
        start_frame = 1
        .help = Number of the first frame.
        .type = int
    }
}
    '''
phil_sec = phil.parse(phil_sec_str)

phil_core = phil.parse('''
to_import {
    include scope ares.import_file.phil_core
    }
    
input_files = None
.help = List of input files in the Ares PHIL format (usually generated by ares.import) If provided, the import is ignored
.type = path

''' + phil_sec_str + '''
integrate {
    include scope ares.integrate.phil_core
}

mask {
    include scope ares.mask.phil_core
}

q_transformation {
    include scope ares.q_transformation.phil_core
}
''',process_includes=True)

def run(params):
    """
    Running function for SEC
    """

    if params.input_files is not None:
        ares.my_print('Reading file headers...')
        files = ares.import_file.ImportFiles(file_phil=params.input_files)
        ares.my_print('Processed {} files.'.format(len(files.files_dict)))
    else:
        ares.my_print('Importing files...')
        files = ares.import_file.ImportFiles(run_phil=params.to_import)
        ares.my_print('Processed {} files.'.format(len(files.files_dict)))
        ares.my_print('Writing list of imported files to {}.'.format(params.to_import.output))
        files.write_groups(params.to_import.output)

    if params.sec.sort:
        files.sort_by_time()




class JobSec(ares.Job):
    def __set_meta__(self):
        '''
        Sets various package metadata
        '''

        self._program_short_description = 'Another angular REduction for Saxs'

        self._program_name = os.path.basename(sys.argv[0])
        self._program_version = __version__

    def __worker__(self):
        '''
        The actual programme worker
        :return:
        '''
        run(self.params)

    def __set_system_phil__(self):
        '''
        Settings of CLI arguments. self._parser to be used as argparse.ArgumentParser()
        '''
        self._system_phil = phil_core

    def __argument_processing__(self):
        '''
        Adjustments of raw input arguments. Modifies self._args, if needed

        '''
        pass

    def __help_epilog__(self):
        '''
        Epilog for the help

        '''
        pass

    def __process_unhandled__(self):
        '''
        Process unhandled CLI arguments into self.params

        :return:
        '''
        self.params.to_import.search_string.extend(self.unhandled)

def main(argv=None):
    job = JobSec()
    return job.job_exit


if __name__ == "__main__":
    sys.exit(main())