import ares
import sys,os
import freephil as phil
import ares.import_file
import ares.q_transformation as q_trans
import ares.mask
import ares.power
import ares.integrate

__all__ = []
__version__ = ares.__version__
prog_short_description = 'Integrates series of frames from SEC-SAXS'

phil_sec_str =  '''
sec {
    sort = True
    .help = Sort the input files by header time. If False, the order as in input list used.
    .type = bool
    
    output {
        prefix = frame
        .help = Prefix of output files
        .type = str
        directory = sec_by_frame
        .help = output directory
        .type = path
        start_frame = 1
        .help = Number of the first frame.
        .type = int
    }
}
    '''
phil_sec = phil.parse(phil_sec_str)

phil_core = phil.parse('''
to_import {
    include scope ares.import_file.phil_core
    }
    
input_files = None
.help = List of input files in the Ares PHIL format (usually generated by ares.import) If provided, the import is ignored
.type = path

''' + phil_sec_str + '''
integrate {
    include scope ares.integrate.phil_core
}

mask {
    include scope ares.mask.phil_core
}

q_transformation {
    include scope ares.q_transformation.phil_core
}

include scope ares.power.phil_job_control
''',process_includes=True)

def run(params):
    """
    Running function for SEC
    """

    threads, jobs = ares.power.get_cpu_distribution(params.job_control)

    if params.input_files is not None:
        ares.my_print('Reading file headers...')
        files = ares.import_file.ImportFiles(file_phil=params.input_files)
        ares.my_print('Processed {} files.'.format(len(files.files_dict)))
    else:
        ares.my_print('Importing files...')
        files = ares.import_file.ImportFiles(run_phil=params.to_import)
        ares.my_print('Processed {} files.'.format(len(files.files_dict)))
        ares.my_print('Writing list of imported files to {}.'.format(params.to_import.output))
        files.write_groups(params.to_import.output)

    if params.sec.sort:
        files.sort_by_time()

    ares.my_print('Q-transformation...')
    det_qs = [q_trans.transform_detector_radial_q(files.files_dict[gr.file[0].path],
                                                 unit=params.q_transformation.units)
             for gr in files.file_groups]

    ares.my_print('Creating masks...')
    masks = [ares.mask.composite_mask(params.mask, files.files_dict[gr.file[0].path])
            for gr in files.file_groups]

    if (params.integrate.q_range[0] == 0) and (params.integrate.q_range[1] == 0):
        qmin = None
        qmax = None
    else:
        qmin = min(params.integrate.q_range)
        qmax = max(params.integrate.q_range)

    for mask, det_q, group in zip(masks, det_qs,files.file_groups):
        ares.my_print('Preparing bins...')
        q_val, q_mask = ares.integrate.prepare_bins(det_q,
                                                    qmin,
                                                    qmax,
                                                    params.integrate.bins_number,
                                                    mask)
        ares.my_print('Using:\nq_min: {qmin:.3f} {un}^-1\nq_max: {qmax:.2f} {un}^-1\nNo.bins: {bins}'.format(qmin=min(q_val),
                                                                                                             qmax=max(q_val),
                                                                                                             bins=len(q_val),
                                                                                                             un=params.q_transformation.units))





class JobSec(ares.Job):
    def __set_meta__(self):
        '''
        Sets various package metadata
        '''

        self._program_short_description = 'Another angular REduction for Saxs'

        self._program_name = os.path.basename(sys.argv[0])
        self._program_version = __version__

    def __worker__(self):
        '''
        The actual programme worker
        :return:
        '''
        run(self.params)

    def __set_system_phil__(self):
        '''
        Settings of CLI arguments. self._parser to be used as argparse.ArgumentParser()
        '''
        self._system_phil = phil_core

    def __argument_processing__(self):
        '''
        Adjustments of raw input arguments. Modifies self._args, if needed

        '''
        pass

    def __help_epilog__(self):
        '''
        Epilog for the help

        '''
        pass

    def __process_unhandled__(self):
        '''
        Process unhandled CLI arguments into self.params

        :return:
        '''
        self.params.to_import.search_string.extend(self.unhandled)

def main(argv=None):
    job = JobSec()
    return job.job_exit


if __name__ == "__main__":
    sys.exit(main())